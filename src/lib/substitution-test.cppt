#include "substitution.h"

using namespace upd::substitution;

@it "segment() is empty by default" {
  segment s;
  @assert(s.empty());
}

@it "segment() constructs from literal" {
  segment s("foo");
  @assert(!s.empty());
  @assert(s.literal == "foo");
  @assert(!s.has_placeholder);
}

@it "segment() constructs from literal and captured group index" {
  segment s(42, "foo");
  @assert(!s.empty());
  @assert(s.literal == "foo");
  @assert(s.has_placeholder);
  @assert(s.placeholder_ix == 42ull);
}

@it "segment() is empty after clear()" {
  segment s(42, "foo");
  s.clear();
  @assert(s.empty());
}

@it "parse() parses empty string" {
  auto result = parse("");
  @assert(result == pattern({{}, {}}));
}

@it "parse() parses single literal" {
  auto result = parse("foobar");
  @assert(result == pattern({{
                                 segment("foobar"),
                             },
                             {}}));
}

@it "parse() parses literal with captured group indices" {
  auto result = parse("foo$1bar$2");
  @assert(result == pattern({{
                                 segment("foo"),
                                 segment(0, "bar"),
                                 segment(1),
                             },
                             {}}));
}

@it "parse() escapes captured group character" {
  auto result = parse("foo\\$1bar");
  @assert(result == pattern({{
                                 segment("foo$1bar"),
                             },
                             {}}));
}

@it "parse() allows to capture literal" {
  auto result = parse("foo(bar)");
  @assert(result == pattern({{
                                 segment("foo"),
                                 segment("bar"),
                             },
                             {{1, 2}}}));
}

@it "parse() allows to recapture captured groups" {
  auto result = parse("foo($1)bar");
  @assert(result == pattern({{
                                 segment("foo"),
                                 segment(0),
                                 segment("bar"),
                             },
                             {{1, 2}}}));
}

@it "resolve() and capture() have correct results" {
  auto pattern = parse("foo($1)");
  auto result = resolve(pattern.segments, {
                                              "tadam!",
                                              {{2, 5}},
                                          });
  @assert(result.value == "foodam");
  @assert(result.segment_start_ids == std::vector<size_t>({0, 3}));
  auto captured =
      capture(pattern.capture_groups, result.value, result.segment_start_ids);
  @assert(captured.value == result.value);
  @assert(captured.captured_groups == upd::captured_string::groups({{3, 6}}));
}
