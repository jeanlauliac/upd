#include "substitution.h"

using namespace upd::substitution;

@case "segment() is empty by default" {
  segment s;
  @expect(s.empty());
}

@case "segment() constructs from literal" {
  segment s("foo");
  @expect(!s.empty());
  @expect(s.literal == "foo");
  @expect(!s.has_captured_group);
}

@case "segment() constructs from literal and captured group index" {
  segment s(42, "foo");
  @expect(!s.empty());
  @expect(s.literal == "foo");
  @expect(s.has_captured_group);
  @expect(s.captured_group_ix == 42);
}

@case "segment() is empty after clear()" {
  segment s(42, "foo");
  s.clear();
  @expect(s.empty());
}

@case "parse() parses empty string" {
  auto result = parse("");
  @expect(result == pattern({ .segments = {}, .capture_groups = {} }));
}

@case "parse() parses single literal" {
  auto result = parse("foobar");
  @expect(result == pattern({ .segments = {
    segment("foobar"),
  }, .capture_groups = {} }));
}

@case "parse() parses literal with captured group indices" {
  auto result = parse("foo$1bar$2");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment(0, "bar"),
    segment(1),
  }, .capture_groups = {} }));
}

@case "parse() escapes captured group character" {
  auto result = parse("foo\\$1bar");
  @expect(result == pattern({ .segments = {
    segment("foo$1bar"),
  }, .capture_groups = {} }));
}

@case "parse() allows to capture literal" {
  auto result = parse("foo(bar)");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment("bar"),
  }, .capture_groups = { { 1, 2 } } }));
}

@case "parse() allows to recapture captured groups" {
  auto result = parse("foo($1)bar");
  @expect(result == pattern({ .segments = {
    segment("foo"),
    segment(0),
    segment("bar"),
  }, .capture_groups = { { 1, 2 } } }));
}

@case "resolve() and capture() have correct results" {
  auto pattern = parse("foo($1)");
  auto result = resolve(pattern.segments, {
    .value = "tadam!",
    .captured_groups = { { 2, 5 } },
  });
  @expect(result.value == "foodam");
  @expect(result.segment_start_ids == std::vector<size_t>({ 0, 3 }));
  auto captured = capture(pattern.capture_groups, result.value, result.segment_start_ids);
  @expect(captured.value == result.value);
  @expect(captured.captured_groups == upd::captured_string::groups({ { 3, 6 } }));
}
